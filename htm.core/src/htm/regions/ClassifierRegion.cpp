/* ---------------------------------------------------------------------
 * HTM Community Edition of NuPIC
 * Copyright (C) 2019, Numenta, Inc.
 *
 * Author: David Keeney, Nov. 2019
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero Public License for more details.
 *
 * You should have received a copy of the GNU Affero Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 * --------------------------------------------------------------------- */

/** @file
 * Implementation of the Classifier Region.
 * The input is normally 
 *    - the encoders's input, quantized into buckets or categories. This is the title for bucket of the current sample.
 *    - and the pattern generated by the SP, TM or whatever, as a result of that encoder input (the current sample).
 * The algorithm will learn the correspondance between these two.
 *
 * The 'pdf' output is a probability distribution function predicting the probability that the
 * given pattern is one of the encoder's buckets that it has learned.
 *
 * The 'titles' output is a list of all of the titles for buckets that it has learned.
 *
 * The 'predicted' output is an index into the 'pdf' and 'titles' arrays corresponding
 * to the bucket that has the highest probability of a match with the given pattern.
 *
 * An example of the bucket values are:
 *   Assume the radius of the encoder is 0.01
 *   The bucket 1.00 will contain all values >= 1.00 and < 1.01.
 *      value encoded         quantized value (or title) of bucket
 *         1.0                     1.00
 *         6.23463745              6.23
 *        -0.45679278             -0.45
 *         0.0045                  0.00
 * The quality of the prediction will depend on the number of samples it is able to learn 
 * for each bucket.  So if there are a lot of potential buckets it will take a lot of samples
 * in order to match a pattern with a bucket with any confidence.
 * For a range of +10.00 to -10.00 with a radius of 0.01 there will be 20000 buckets,
 * each will need at least 100 or so samples before the 'predicted' output is significant.
 * 
 * Note that the classifier is not biologically inspired.  The brain does not need to turn
 * its internal SDR patters back into original input. But this is useful for experimenting
 * with implementations.
 *
 */

#include <htm/regions/ClassifierRegion.hpp>

#include <htm/engine/Input.hpp>
#include <htm/engine/Output.hpp>
#include <htm/engine/Region.hpp>
#include <htm/engine/Spec.hpp>
#include <htm/ntypes/Array.hpp>
#include <htm/utils/Log.hpp>

#include <memory>
#include <vector>
#include <map>

namespace htm {


/* static */ Spec *ClassifierRegion::createSpec() {
  Spec *ns = new Spec();
  ns->parseSpec(R"(
   {name: "ClassifierRegion",
    parameters: {
      learn:    { description: "if true, it performs the learn step",
                           type: Bool, access: ReadWrite, default: "true"},
    },
    inputs: {
      bucket:  { description: "The quantized value of the current sample, one from each encoder if more than one, for the learn step",
                           type: Real64,  count: 0},  
      pattern: { description:  "An SDR output bit pattern for a sample.  Usually the output of the SP or TM. For example: activeCells from TM",  
                           type: SDR, count: 0} 
    }, 
    outputs: {
      pdf:       { description: "probability distribution function (pdf) for each category or bucket. Sorted by title.  Warning, buffer length will grow.",
                           type: Real64, count: 0},
      titles:    { description: "Quantized values of used samples which are the Titles corresponding to the pdf indexes. Sorted by title. Warning, buffer length will grow.",
                           type: Real64, count: 0},
      predicted: { description: "An index (into pdf and titles) with the highest probability of being the match with the current pattern.",
                           type: UInt32, count: 1}
    }
   }
  )");

  return ns;
}


ClassifierRegion::ClassifierRegion(const ValueMap &par, Region *region) : RegionImpl(region) {

  spec_.reset(createSpec());
  ValueMap params = ValidateParameters(par, spec_.get());
  learn_ = params["learn"].as<bool>();
  Real32 alpha = 0.001f;

  classifier_ = std::make_shared<Classifier>(alpha);

}

ClassifierRegion::ClassifierRegion(ArWrapper &wrapper, Region *region)
    : RegionImpl(region) {
  cereal_adapter_load(wrapper);
}
ClassifierRegion::~ClassifierRegion() {}

void ClassifierRegion::initialize() {}


Dimensions ClassifierRegion::askImplForOutputDimensions(const std::string &name) {
  Dimensions dim1 = {1};
  if (name == "pdf") {
    // The size is determined at runtime.  Its the size of the numCategories_.
    // As new values are learned, this value grows.  So, what we will do is set this
    // to a value of 1.  Then the compute() function will need to adjust the buffer size as needed.
    return dim1;
  } else if (name == "titles") {
    // The size is determined at runtime.  Same length and order as pdf.
    // Each element is the quantized value (or bucket value) for samples used.
    return dim1;
  } else if (name == "predicted") {
    // This is a single value, an index into pdf and titles.
    return dim1;
  } else
    return RegionImpl::askImplForOutputDimensions(name);
}



void ClassifierRegion::compute() {
  SDR &pattern = getInput("pattern")->getData().getSDR();
  // Note: if there is no link to 'pattern' input, the 'pattern' SDR length is 0
  //       and SDRClassifier::infer() will throw an exception.

  if (learn_) {
    Array &b = getInput("bucket")->getData();
    // 'bucket' is a list of quantized samples being processed for this iteration.
    // There are one of these for each encoder (or value being encoded).
    // The values might not be consecutive, or in different ranges, or different things entirely.
    // We build a map and a corresponding vector containing the quantized samples actually used.
    // This vector becomes the titles. The index into this list will be a consecutive list that 
    // we can presented to the Classifier which produces the pdf.  Note that the indexes used
    // by the classifier are not sorted by title but rather by the order in which an index is first seen.
    std::vector<UInt> categoryIdxList;
    Real64 *quantizedSample = reinterpret_cast<Real64*>(b.getBuffer());
    UInt c = 0;
    for (size_t i = 0; i < b.getCount(); i++) {
      auto it = bucketListMap.find(quantizedSample[i]);
      if (it == bucketListMap.end()) {
        // This is a sample we have not seen before. Add it to the bucketList.
        c = static_cast<UInt>(bucketList.size());
        bucketList.push_back(quantizedSample[i]);
        bucketListMap[quantizedSample[i]] = c;
      } else {
        c = it->second;
      }
      categoryIdxList.push_back(c);
    }
    classifier_->learn(pattern, categoryIdxList);
  }
  PDF pdf = classifier_->infer(pattern);

  // Adjust the buffer size to match the pdf.
  if (getOutput("pdf")->getData().getCount() < pdf.size()) {
    UInt size = static_cast<UInt>(pdf.size());
    getOutput("pdf")->resize(size);
    getOutput("titles")->resize(size);
  }

  // Populate the outputs. pdf and titles output arrays will be sorted by the title.
  // The predicted output is an index into those sorted arrays.
  Real64 *out = reinterpret_cast<Real64 *>(getOutput("pdf")->getData().getBuffer());
  Real64 *titles = reinterpret_cast<Real64 *>(getOutput("titles")->getData().getBuffer());
  UInt32 *predicted = reinterpret_cast<UInt32 *>(getOutput("predicted")->getData().getBuffer());
  Real64 m = 0.0;
  size_t j = 0;
  predicted[0] = 0;
  for (auto itm: bucketListMap) {
    size_t i = itm.second;
    if (pdf[i] > m) {
      m = pdf[i];
      predicted[0] = static_cast<UInt32>(j);  // index of the quantized sample with the highest probability of matching the pattern
    }
    out[j] = pdf[i];
    titles[j] = bucketList[i];
    j++;
  }
}


void ClassifierRegion::setParameterBool(const std::string &name, Int64 index, bool val) {
  if (name == "learn")
    learn_ = val;
  else
    RegionImpl::setParameterBool(name, index, val);
}

bool ClassifierRegion::getParameterBool(const std::string &name, Int64 index) const {
  if (name == "learn")
    return learn_;
  else  return RegionImpl::getParameterBool(name, index);
}

bool ClassifierRegion::operator==(const RegionImpl &other) const {
  if (other.getType() != "ClassifierRegion") return false;
  const ClassifierRegion &o = reinterpret_cast<const ClassifierRegion &>(other);
  if (learn_ != o.learn_)  return false;
  for (size_t i = 0; i < bucketList.size(); i++) {
    if (bucketList[i] != o.bucketList[i])
      return false;
  }
  if (*classifier_ != *o.classifier_) return false; 
  return true;
}


} // namespace htm
